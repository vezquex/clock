<!doctype html>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='theme-color' content='#000000'>
<title>
	Frans Character Set
</title>
<style type='text/css'>
	:root {
		color-scheme: dark;
	}
	* {
		box-sizing: border-box;
	}
	body {
		background: #111;
		margin: 0;
		overflow-x: hidden;
	}
	.grow {
		flex-grow: 1;
	}
	.column {
		display: flex;
		flex-direction: column;
	}
</style>

<div class='column' style='min-height:100vh;'>
	<div id='face_box' class='grow'>
		<canvas id='face'></canvas>
	</div>
</div>

<script type='text/javascript'>
const {floor, max, min} = Math

let palettes
const color_palettes = {
	'black': '#000000',
	'gray_1_3': '#804040',
	'gray_2_3': '#5555A5',
	'white': '#F1EDDB',
}

const themes = {
	Dark: {
		_scale: ['black', 'gray_1_3', 'gray_2_3', 'white'],
		_body: '3',
		background: color_palettes.black,
		color: color_palettes.white,
	},
}
for(k in themes){
	const theme = themes[k]
	;(theme._scale||[]).forEach((color, i)=>theme[i] = color_palettes[color])
	Object.assign(theme, color_palettes)
}

const p = 2
const ch = 5*p
const cw = 3*p
const grid_h = ch + p
const grid_w = cw + p
const grid_w2 = grid_w * 2
const hch = ch/2
const hcw = cw/2

const can = document.getElementById('face')
const c = can.getContext('2d')

const height = 37
const width = 53
const pad_h = 1
const pad_v = p

// zoom
let z = 1

can.height = height * z
can.width = width * z
c.setTransform(z, 0, 0, z, 0, 0)

function setTheme(theme){
	palettes = themes[theme]
	can.style.backgroundColor = palettes.background
	synchronize()
}

function synchronize(){
	window.clearTimeout(window.synchronizeTimeout)
	display()
}

function zeropad2(s){
	return ('0' + s).slice(-2)
}

const pad = .25
const dpad = pad*2
const hpad = pad/2
const chp = ch - pad
const cwp = cw - pad
const slope = 10.4125 / 6.5
const inset = 1.25 + hpad
const insetx = cw - inset
const insety = ch - inset
const seg_paths = {
	cd: [[p,4*p], [p,5*p], [2*p,5*p], [2*p,4*p]],
	cf: [[p,3*p], [p,4*p], [2*p,4*p], [2*p,3*p]],
	cm: [[p,2*p], [p,3*p], [2*p,3*p], [2*p,2*p]],
	cs: [[p,p], [p,2*p], [2*p,2*p], [2*p,p]],
	cu: [[p,0], [p,p], [2*p,p], [2*p,0]],
	ld: [[0,4*p], [0,5*p], [p,5*p], [p,4*p]],
	lf: [[0,3*p], [0,4*p], [p,4*p], [p,3*p]],
	lm: [[0,2*p], [0,3*p], [p,3*p], [p,2*p]],
	ls: [[0,p], [0,2*p], [p,2*p], [p,p]],
	lu: [[0,0], [0,p], [p,p], [p,0]],
	rd: [[2*p,4*p], [2*p,5*p], [3*p,5*p], [3*p,4*p]],
	rf: [[2*p,3*p], [2*p,4*p], [3*p,4*p], [3*p,3*p]],
	rm: [[2*p,2*p], [2*p,3*p], [3*p,3*p], [3*p,2*p]],
	rs: [[2*p,p], [2*p,2*p], [3*p,2*p], [3*p,p]],
	ru: [[2*p,0], [2*p,p], [3*p,p], [3*p,0]],
	x: [[0,0]],
}
function mask_segs(mask, segs){
	let s = []
	let i = 0
	while(mask){
		if(mask & 1){
			s.push(segs[i])
		}
		++i
		mask >>= 1
	}
	return s
}

const seg_order = [
'lu','cu','ru',
'ls','cs','rs',
'lm','cm','rm',
'lf','cf','rf',
'ld','cd','rd',
'x',
].reverse()
const char_masks = {
	'□': 0b1111111111111111,
	' ': 0,
	'0': 0b1111011011011110,
	'1': 0b1100100100100100,
	'2': 0b1110011111001110,
	'3': 0b1110010110011110,
	'4': 0b1011011110010010,
	'5': 0b1111001110011110,
	'6': 0b1111001111011110,
	'7': 0b1110010101001000,
	'8': 0b1111011111011110,
	'9': 0b1111011110011110,
	'[': 0b0110100100100110,
	']': 0b1100100100101100,
	'\\':0b0,
	';': 0b0,
	"'": 0b0,
	',': 0b0,
	'.': 0b0000000000000100,
	'/': 0b0,
	'{': 0b0110101100100110,
	'}': 0b1100100110101100,
	'|': 0b0,
	':': 0b0000100000100000,
	'"': 0b1011010000000000,
	'<': 0b0010101000100010,
	'>': 0b1000100010101000,
	'?': 0b1110010100000100,
	'`': 0b1000100000000000,
	'-': 0b0000001110000000,
	'=': 0b0001110001110000,
	'~': 0b0001100110000000,
	'!': 0b0100100100000100,
	'¡': 0b0100000100100100,
	'@': 0b1110011111011110,
	'#': 0b0101110101110100,
	'$': 0b0101111111110100,
	'%': 0b1010010101001010,
 	'^': 0b0101010000000000,
	'&': 0b0,
	'*': 0b1010101010000000,
	'(': 0b0010100100100010,
	')': 0b1000100100101000,
	'_': 0b1110,
	'+': 0b0000101110100000,
	'A': 0b1111011111011010,
	'B': 0b1111011111011110,
	'C': 0b1111001001001110,
	'D': 0b1111011011011110,
	'E': 0b1111001101001110,
	'F': 0b1111001101001000,
	'G': 0b1111001011011110,
	'H': 0b1011011111011010,
	'I': 0b0100100100100100,
	'J': 0b0010010011011110,
	'K': 0b1011011101011010,
	'L': 0b1001001001001110,
	'M': 0b1011111111011010,
	'N': 0b1011111111111010,
	'O': 0b1111011011011110,
	'P': 0b1111011111001000,
	'Q': 0b1111011011111110,
	'R': 0b1111011111011010,
	'S': 0b1111001110011110,
	'T': 0b1110100100100100,
	'U': 0b1011011011011110,
	'V': 0b1011011011110100,
	'W': 0b1011011011111010,
	'X': 0b1011011111011010,
	'Y': 0b1011011110100100,
	'Z': 0b1110111101001110,
}
const segs = seg_order.map(k => seg_paths[k])
const char_paths = Object.fromEntries(
	Object.entries(char_masks).map(
		([k, mask], i) => [k, mask_segs(mask, segs)]
	)
)

function shape(path, x, y, m = 1){
	m = m*z
	c.beginPath()
	c.moveTo((path[0][0] + x)*m, (path[0][1] + y)*m)
	for(i=1; i<path.length; ++i){
		c.lineTo((path[i][0] + x)*m, (path[i][1] + y)*m)
	}
	c.fill()
}

function draw_char(s, x, y, m = 1, paths = char_paths){
	(paths[s] || paths['□']).forEach(
		path => shape(path, x, y, m)
	)
}

function draw_str(chars, x, y, m = 1, paths, gw = grid_w){
	if(!(chars instanceof Array)){
		chars = (chars+'').split('')
	}
	chars.forEach((s, i) => {
		draw_char(s, x + i * gw, y, m, paths)
	})
}

const face_box = document.getElementById('face_box')
function resize(event){
	const scale = window.devicePixelRatio || 1
	const face_box_height = floor(window.innerHeight) - 1
	z = max(1, floor(min(
		window.innerWidth / width,
		face_box_height / height,
	)))
	face_box.style.height = face_box_height + 'px'
	can.height = height * scale * z
	can.width = width * scale * z
	can.style.height = (height*z)+'px'
	can.style.width = (width*z)+'px'
	c.scale(scale, scale)
	synchronize()
}

window.addEventListener('resize', resize)
window.screen.orientation.addEventListener('change', resize)

function display(t){
	c.fillStyle = palettes.color
	c.clearRect(0, 0, width*z, height*z)
	let x = pad_h, y = pad_v - grid_h, m = .5
	const out = `\`1234567890-=~!@#$%^&*()_+[]\\;',./    □{}|:"<>?¡    ABCDEFGHIJKLMNOPQRSTUVWXYZ`
	let i = 0
	let w = 13
	;[...Array(8)].forEach(() =>
		draw_str(out.slice(i, i+=w), x/m, y+=grid_h, m)
	)
}

setTheme('Dark')
resize()

</script>