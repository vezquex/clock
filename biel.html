<!doctype html>
<meta charset='utf-8'/>
<meta name='viewport' content='width=device-width, initial-scale=1'/>
<meta name='theme-color' content='#000000'/>
<title>
	Biel Dive Watch
</title>
<style type='text/css'>
	*, *::before, *::after {
		box-sizing: border-box;
	}
	:root {
		accent-color: var(--accent);
		color-scheme: dark;
	}
	body {
		background: #000;
		overflow: hidden;
	}
	body, .btn, input, select {
		font-family: sans-serif;
		font-size: 1em;
		margin: 0;
	}
	details {
		opacity: 0.5;
	}
	input, select, .label, summary {
		padding: 0 .5em;
	}
	input {
		width: 100%;
	}
	select {
		min-width: 8rem;
	}
	summary {
		cursor:pointer;
		list-style: none;
		user-select: none;
	}
	text {text-anchor:middle;fill:var(--text);}
	.abs { position:absolute; }
	.btn {
		border-color: rgba(0, 0, 0, .5);
		border-style: outset;
		border-width: 0px;
		cursor: pointer;
		padding: 0 .5em;
		text-decoration: none;
	}
	.column { display: flex; flex-direction: column; }
	.cursive {font-family: 'Dancing Script', cursive; letter-spacing: -1px; font-style:italic; }
	.home {
		border-color: inherit;
		border-width: 1px 1px 0 0;
		position: absolute;
		right:0;
		text-align: right;
		top:0;
		width: 50%;
	}
	.hotkey { text-decoration: underline dotted; }
	.info {font-size: 34px; letter-spacing: 1px; font-weight: 300;}
	.mono {font-family: 'Roboto Mono', monospace;}
	.row { display: flex; }
	.sans {font-family: Roboto, sans-serif; letter-spacing: 3px;}
	.svg {
		height: 100vh;
		margin: 0 auto;
		position:absolute;
		width: 100vw;
	}
	.thick { line-height: 3em; }
	.wide { width: 100vw; }
</style>
<div style='position:absolute;top:0;bottom:0;left:0;right:0;display:flex;align-content: center;'>
<svg version="1.1" viewBox="0 0 2048 2048" xmlns="http://www.w3.org/2000/svg" class='svg'>
	<rect id="canvas" x="0" y="0" width="2048" height="2048" fill="none"/>
	<circle id="edge" style="fill:var(--edge);" r="1024" cx="1024" cy="1024"/>
	<circle id="bezel" style="fill:var(--bezel);" r="968" cx="1024" cy="1024"/>
	<circle id="dial" style="fill:var(--dial);" r="780" cx="1024" cy="1024"/>
</svg>
<canvas id='waves' class='abs'></canvas>
<canvas id='face-static' class='abs'></canvas>
<svg version="1.1" viewBox="0 0 2048 2048" xmlns="http://www.w3.org/2000/svg" class='svg'>
<g id="bezel_group">
<path id="twelve_bezel" style="stroke:var(--mark);stroke-width:16;fill:none;" d="M 1024,224 l -118,-140 q 118,-16 236,0z"/>
<circle id="twelve_pip" style="fill:var(--mark);stroke:var(--edge);stroke-width:8;" r="32" cx="1024" cy="132"/>
<g style="fill:var(--mark);font:120px sans-serif;">
	<text transform="rotate(55 1024 1024) translate(1024 176) scale(2.5 1)">
		1
	</text>
	<text transform="rotate(63 1024 1024) translate(1024 176) scale(3 1)">
		0
	</text>
	<text transform="rotate(114 1024 1024) translate(1024 176) scale(2.5 1)">
		2
	</text>
	<text transform="rotate(125 1024 1024) translate(1024 176) scale(3 1)">
		0
	</text>
	<text transform="rotate(174 1024 1024) translate(1024 176) scale(3 1)">
		3
	</text>
	<text transform="rotate(186 1024 1024) translate(1024 176) scale(3 1)">
		0
	</text>
	<text transform="rotate(234 1024 1024) translate(1024 176) scale(3 1)">
		4
	</text>
	<text transform="rotate(246 1024 1024) translate(1024 176) scale(3 1)">
		0
	</text>
	<text transform="rotate(294 1024 1024) translate(1024 176) scale(3 1)">
		5
	</text>
	<text transform="rotate(306 1024 1024) translate(1024 176) scale(3 1)">
		0
	</text>
</g>
</g>
<g transform="translate(1024 1512)">
	<rect id="date_window_bg" x="-64" y="-68" width="128" height="146" style="fill:var(--dial);stroke:var(--dial);stroke-width:12px;"/>
	<rect id="date_window_border" x="-64" y="-68" width="128" height="146" style="fill:none;stroke:rgba(255,255,255,.1);stroke-width:12px;"/>
	<text id="day_of_month" dominant-baseline="central" style="fill:var(--mark);font-size:96px;font-family:'Roboto Mono',monospace;" transform="scale(1 1.5)"></text>
</g>
<rect x="988" y="1612" width="72" height="52" style="fill:var(--mark);stroke:var(--edge);stroke-width:8px;"/>
<g transform="translate(1024 664)">
	<circle r="46" style="fill:var(--dial)"/>
	<text style="font:bold 110px Times, serif;" dominant-baseline="central">
		Θ
	</text>
</g>
<g transform="translate(1024 708)">
	<rect height="80" width="300" x="-150" y="0" style="fill:var(--dial)"/>
	<text transform="scale(1.25 1)"
	class="mono" dominant-baseline="hanging"
	style="font-size:80px;"
	>
	THETA
	</text>
</g>
<g transform="translate(1024 788)">
	<rect height="72" width="384" x="-184" y="0" style="fill:var(--dial)"/>
	<text class="cursive"	dominant-baseline="hanging"
	style="fill:var(--highlight);font-size:50px;font-weight:bold;"
	transform="scale(2 1)">
		<tspan style="font-size:1.5em;">S</tspan><tspan dy="10">uperstar</tspan>
	</text>
</g>
<g transform="translate(1024 860)">
	<rect height="30" width="300" x="-150" y="0" style="fill:var(--dial)"/>
	<text class="sans info" dominant-baseline="hanging">
		PROFESSIONAL
	</text>
</g>
<g transform="translate(1024 1094)">
	<rect height="50" width="130" x="-65" y="-5" style="fill:var(--dial)"/>
	<text class="sans info" style="opacity:.3;font-weight:lighter;font-size:44px;" dominant-baseline="hanging">
		[SiO<tspan dy="10">2</tspan><tspan dy="-10">]</tspan>
	</text>
</g>
<g transform="translate(1024 1208)">
	<rect height="40" width="228" x="-114" style="fill:var(--dial)"/>
	<text class="sans info" dominant-baseline="hanging">
		JAVASCRIPT
	</text>
</g>
<g transform="translate(1024 1248)">
	<rect height="52" width="452" x="-225" y="-12" style="fill:var(--dial)"/>
	<text class="sans info" dominant-baseline="hanging">
		VIRTUAL CHRONOMETER
	</text>
</g>
<g transform="translate(1024 1288)">
	<rect height="34" width="264" x="-132" style="fill:var(--dial)"/>
	<text class="sans info" dominant-baseline="hanging">
		300m ≈ 1000ft
	</text>
</g>
<path id="curve"
pathLength="2"
d="
M 1024, 254
a 746,746 0 1,0 5,0
" fill='none'/>
<text class="mono" style="font-size:24px;">
	<textPath href="#curve"	startOffset="1"
	>HTML<tspan style="font-size:180px;"> </tspan>MADE</textPath>
</text>
</svg>
<canvas id='face' class='abs'></canvas>
</div>
<details class='abs column wide'>
	<summary accesskey='s' title='Settings' class='btn thick'>☰</summary>
	<a href='..' accesskey='h' class='btn home thick'>
		<span class='hotkey'>H</span>ome
	</a>
	<label class='row thick'>
		<span class='label'><span class='hotkey'>O</span>ffset</span>
		<input id='offset' accesskey='o' value='0' type='range' max='86400000' step='60000' onInput='synchronize()'>
	</label>
	<label class='row thick'>
		<span class='label'><span class='hotkey'>B</span>ezel</span>
		<input id='bezel_offset' accesskey='b' value='120' type='range' max='120' step='1' onInput='display_static()'>
	</label>
	<label class='row thick'>
		<span class='label'><span class='hotkey'>T</span>heme</span>
		<select id='theme' accesskey='t' onChange='setTheme(this.value)'></select>
	</label>
</details>

<script type='text/javascript'>
const bps = 4
const _ = void 0
const doc = document
const $ = doc.querySelector.bind(doc)
const eid = doc.getElementById.bind(doc)

let palettes
const color_palettes = {
	bezel: '#000000',
	dial: '#000000',
	edge: '#C0C0C0',
	highlight: '#C00000',
	mark: '#FFFFFF',
	text: '#FFFFFF',
	wave: 'rgba(255,255,255,.1)',
}
const themes = {
	'Black': {},
	'Blue': {
		bezel: '#001830',
		dial: '#002040',
	},
	'Cyan': {
		bezel: '#003030',
		dial: '#004040',
	},
	'Gray': {
		bezel: '#303030',
		dial: '#404040',
	},
	'Green': {
		bezel: '#003000',
		dial: '#004000',
	},
	'Purple': {
		bezel: '#300030',
		dial: '#400040',
	},
	'Red': {
		bezel: '#300000',
		dial: '#400000',
	},
	'Tan': {
		bezel: '#262427',
		dial: '#424242',
		edge: '#CFCAC7',
		mark: '#D2A67F',
		text: '#D2A67F',
		wave: 'rgba(0,0,0,0)',
	},
}
const height = 128
const width = height
const half = width / 2
const scale = 1024
const bezel_r = 50
const bezel_mark_len = 9.5
const bezel_mark_r = 1
const bezel_minute_len = bezel_mark_r * 3
const dash = 1.2
const hour_r = 35
const hour_r_rect = 28
const hour_len = 12
const hour_radius = 4
const hour_thick = 2.25
const lineWidth = .5
const lineWidth_2 = lineWidth / 2
const minute_len = 2.25
const minute_len_five = minute_len * 1.5
const minute_r = half * 720/1024
const minute_thick = 0.2
const minute_thick_five = minute_thick * 1.5
const second_hand_eye = 2.5
const second_hand_h = minute_r - minute_len
const shadowBlur = .5
const shadowOffset = .25
const thick = .2
const tw_gap = 3
const waves = 20
const waves_r = 40

// zoom
let z = 1

const {abs, cos, min, sin, sqrt} = Math
const phi = (1 + sqrt(5)) * .5
const tau = 2 * Math.PI
const tau_2 = tau / 2
const tau_4 = tau / 4
const tau_12 = tau / 12
const tau_60 = tau / 60
const pent_cross = 2 * sin(tau/5)
const pent_h = phi / 2 + 1
const pent_tip = 1 - cos(tau/5)

for(k in themes){
	themes[k] = Object.assign({}, color_palettes, themes[k])
}
const colors = Object.keys(color_palettes)
eid('theme').innerHTML = Object.keys(themes).map(
	t => `<option value='${t}'>${t.replaceAll('_',' ')}</option>`
).join('')


const face = eid('face')
const fc = face.getContext('2d')

const can = eid('face-static')
const c = can.getContext('2d')

const waves_can = eid('waves')
const waves_c = waves_can.getContext('2d')

const faces = [can, face, waves_can]
const faces_c = [c, fc, waves_c]

function resize(){
	const canvas_el = eid('canvas')
	const rect = canvas_el.getBoundingClientRect()
	const scale = window.devicePixelRatio || 1
	z = min(
		(rect.height / height),
		(rect.width / width),
	)
	faces.forEach(can =>{
		can.height = height * scale * z
		can.width = width * scale * z
		can.style.left = rect.x + 'px'
		can.style.top = rect.y + 'px'
		can.style.height = rect.height+'px'
		can.style.width = rect.width+'px'
	})
	faces_c.forEach(
		c => c.scale(scale, scale)
	)
	display_static()
	synchronize()
}
window.addEventListener('resize', resize)

const bezel_el = eid('bezel_offset')
const offset_el = eid('offset')

function setTheme(theme){
	palettes = themes[theme]
	$(`#theme [value=${theme}]`).selected = true
	doc.documentElement.style.setProperty('--accent', palettes.highlight)
	colors.forEach(color => {
		doc.documentElement.style.setProperty('--'+color, palettes[color])
	})
	display_static()
	synchronize()
}

const delay = 1000 / bps
function synchronize(){
	window.clearTimeout(window.synchronizeTimeout)
	const offset = Number(offset_el.value)
	let t = new Date(Date.now() + offset)
	// t = new Date(2020,0,28,10,15,0,0)
	display(t)
	const r = delay - (t % delay)
	window.synchronizeTimeout = window.setTimeout(synchronize, r)
}

function shapec(c, path, x = 0, y = 0, m = 1, fill = true, beginPath = true){
	m = m*z
	beginPath && c.beginPath()
	c.moveTo((path[0][0] + x)*m, (path[0][1] + y)*m)
	for(i=1; i<path.length; ++i){
		c.lineTo((path[i][0] + x)*m, (path[i][1] + y)*m)
	}
	fill && c.fill()
}
const shape = shapec.bind(null, c)
function shapep(){
	const a = [...arguments]
	a[5] = a[6] = false
	shapec.apply(null, a)
}

function circle(r, x, y, m = 1){
	m = m*z
	c.beginPath()
	c.arc(x*m, y*m, r*m, 0, tau)
	c.fill()
}

function rot(a, [x,y]){
	return [
		x * cos(a) + y * sin(a),
		y * cos(a) - x * sin(a),
	]
}

const rect = (w, h) => ([
	[0, 0],
	[w, 0],
	[w, h],
	[0, h],
])

const rect_my = (y, h) => ([
	[0, -y],
	[h, -y],
	[h, y],
	[0, y],
])

const bezel_index = rect_my(bezel_mark_r, bezel_mark_len)
const bezel_minute = rect_my(bezel_mark_r, bezel_minute_len)

function polygon(sides, radius = 1, rot = tau_4){
	return Array(sides).fill().map((_,i)=>([
		radius * cos(i * tau / sides - rot),
		radius * sin(i * tau / sides - rot),
	]))
}

const arm_w = 2
const arm_w2 = 3
const base_h = 1.5
const base_w = 4
const fudge = .25
const fudge_s = .05
const hour_h = hour_r - hour_radius
const lume_inset = 2
const lume_inset_arm = .75
const minute_h = minute_r - minute_len_five - 1.5
const minute_head_h = 9
const stem_h = 5
const stem_w = 1.5
const arm_h = minute_h - stem_h - minute_head_h
const minute_head_w = minute_head_h*4/3
const hour_head_w = minute_head_w * 0.828633
const pr = hour_head_w / phi
const pc = hour_h - pr
const cross = pr * pent_cross
const tip = pr * pent_tip
const hour_right_arm = [
	[stem_h, base_w/2 - arm_w],
	[hour_h - tip, cross/2 - arm_w2],
	[hour_h - tip, cross/2],
	[stem_h, base_w/2],
]
const hour_left_arm = hour_right_arm.map(([x,y])=>[x,-y]).reverse()
const hour_arm_slope_inner = (hour_right_arm[1][1] - hour_right_arm[0][1]) / (hour_right_arm[1][0] - hour_right_arm[0][0])
const hour_arm_slope_outer = (hour_right_arm[3][1] - hour_right_arm[2][1]) / (hour_right_arm[3][0] - hour_right_arm[2][0])
const hour_arm_lume_w_inner = hour_h - pr * pent_h - (stem_h + base_h)
const hour_arm_lume_w_outer = stem_h + base_h - (hour_h - pr * pent_h)
const hour_right_arm_lume = [
	[stem_h + base_h, base_w/2 - arm_w + lume_inset_arm],
	[hour_h - pr * pent_h, base_w/2 - arm_w + lume_inset_arm + hour_arm_slope_inner * hour_arm_lume_w_inner],
	[hour_h - pr * pent_h, base_w/2 - lume_inset_arm - hour_arm_slope_outer * hour_arm_lume_w_outer],
	[stem_h + base_h, base_w/2 - lume_inset_arm],
]
const hour_left_arm_lume = hour_right_arm_lume.map(([x,y])=>[x,-y])
const minute_right_arm = [
	[0, base_w/2 - arm_w],
	[arm_h + fudge, minute_head_w/2 - arm_w2],
	[arm_h, minute_head_w/2],
	[0, base_w/2],
]
const minute_left_arm = minute_right_arm.map(([x,y])=>[x,-y]).reverse()
const minute_head = [
	[0, 0],
	[minute_head_h, minute_head_w/2],
	[0, minute_head_w],
]
const minute_head_lume = [
	[0, lume_inset],
	[minute_head_h - 1.5*lume_inset, minute_head_w/2],
	[0, minute_head_w - lume_inset],
]
const minute_right_arm_lume = [
	[base_h, base_w/2 - arm_w + lume_inset_arm],
	[arm_h, minute_head_w/2 - arm_w2 + lume_inset_arm],
	[arm_h, minute_head_w/2 - lume_inset_arm],
	[base_h, base_w/2 - lume_inset_arm/2],
]
const minute_left_arm_lume = minute_right_arm_lume.map(([x,y])=>[x,-y]).reverse()

let x = -7.4 - lineWidth_2
let y = 1 - lineWidth_2
let l = 10 - lineWidth
const second_tail = [
	[-2,0], [x,0], [x,y], [x-l,y], [x-l,-y], [x,-y], [x,0]
]

const day_of_month_el = eid('day_of_month')

function shadow_on(c){
	c.shadowBlur = z*shadowBlur
	c.shadowOffsetX = c.shadowOffsetY = z*shadowOffset
}
function shadow_off(c){
	c.shadowBlur = 0
	c.shadowOffsetX = 0
	c.shadowOffsetY = 0
}

function display(t){
	const hours = t.getHours()
	const minutes = t.getMinutes()
	const seconds = t.getSeconds() + t.getMilliseconds() / 1000
	const day_of_month = day_of_month_el.innerHTML = (t.getDate()+'')

	fc.fillStyle = palettes.mark
	fc.shadowColor = 'rgba(0,0,0,1)'
	fc.strokeStyle = palettes.edge
	fc.save()
	fc.clearRect(0, 0, width*z, height*z)
	fc.translate(half*z, half*z)
	fc.rotate(-tau_4)

	const hr = hours % 12

	face.innerText = `The time is ${hr} hours, ${(minutes+'').padStart(2, '0')} minutes, and ${seconds} seconds, on day ${day_of_month} of the month.`

	// hour hand
	fc.save()
	shadow_on(fc)
	fc.rotate(
		(hr / 12 + minutes / 720 + seconds / 43200) * tau,
	)
	fc.fillStyle = palettes.edge
	fc.arc(0, 0, 3.75*z, 0, tau)
	shapep(fc, rect(base_h, base_w), stem_h, -base_w/2)
	shapep(fc, rect(stem_h + fudge, stem_w), 0, -stem_w/2)
	shapep(fc, hour_left_arm)
	shapep(fc, hour_right_arm)
	shapep(fc, polygon(5, pr, 0), pc)
	fc.fill()
	shadow_off(fc)
	fc.fillStyle = palettes.mark
	shapec(fc, hour_left_arm_lume)
	shapec(fc, hour_right_arm_lume)
	// hour hand lume
	fc.beginPath()
	fc.arc(pc*z, 0, z*pr/phi, 0, tau)
	fc.fill()
	fc.restore()

	// minute hand
	fc.save()
	fc.rotate((minutes / 60 + seconds / 3600) * tau)
	fc.fillStyle = palettes.edge
	shadow_on(fc)
	fc.beginPath()
	shapep(fc, minute_head, minute_h - minute_head_h, -minute_head_w/2)
	shapep(fc, minute_left_arm, stem_h)
	shapep(fc, minute_right_arm, stem_h)
	shapep(fc, rect(base_h, base_w), stem_h, -base_w/2)
	shapep(fc, rect(stem_h, stem_w), 0, -stem_w/2)
	fc.arc(0, 0, 3*z, 0, tau)
	fc.fill()
	shadow_off(fc)
	fc.fillStyle = palettes.mark
	shapec(fc, minute_head_lume, stem_h + arm_h + lume_inset/2, -minute_head_w/2)
	shapec(fc, minute_left_arm_lume, stem_h)
	shapec(fc, minute_right_arm_lume, stem_h)
	fc.restore()

	// second hand
	fc.save()
	fc.lineWidth = lineWidth*z
	fc.rotate(seconds * tau_60)
	fc.strokeStyle = palettes.edge
	shadow_on(fc)
	fc.beginPath()
	// tip
	fc.lineTo(second_hand_h*z, 0)
	// eye
	fc.arc(28*z, 0, second_hand_eye * z, -tau_2, tau_2)
	// pivot
	fc.arc(0, 0, 2*z, 0, tau)
	// tail
	shapep(fc, second_tail)
	fc.stroke()
	shadow_off(fc)
	// tail
	fc.fillStyle = palettes.edge
	shapec(fc, second_tail)
	// eye
	fc.fillStyle = palettes.mark
	fc.beginPath()
	fc.arc(28*z, 0, (second_hand_eye - lineWidth_2 + fudge_s) * z, -tau_2, tau_2)
	fc.fill()

	fc.fillStyle = palettes.edge
	fc.beginPath()
	// pivot
	fc.arc(0, 0, 1.8*z, 0, tau)
	fc.fill()

	// tip
	fc.lineWidth = lineWidth*z
	fc.strokeStyle = palettes.highlight
	fc.beginPath()
	fc.moveTo(30.75*z, 0)
	fc.lineTo(second_hand_h*z, 0)
	fc.stroke()

	// stem
	shadow_on(fc)
	fc.beginPath()
	fc.arc(0, 0, .375*z, 0, tau)
	fc.fill()

	fc.restore()
	fc.restore()
}

function display_static(){
	if(bezel_el.value === '0'){
		bezel_el.value = bezel_el.max
	}
	const bezel_frac = Number(bezel_el.value) / 120
	const bezel_angle = bezel_frac * tau
	eid('bezel_group').setAttribute(
		'transform',
		`rotate(${360 * bezel_frac} 1024 1024)`,
	)

	// waves
	const waves_b = waves
	const amplitude = 2
	const frequency = waves_r
	waves_c.save()
	waves_c.clearRect(0, 0, width*z, height*z)
	waves_c.lineWidth = 1*z
	waves_c.fillStyle = palettes.wave
	Array(waves).fill().map((_, i) => i)
	.forEach(i => {
		let frac = 2 * (i + 2/3) / waves_b
		let y = (waves_r * frac) + half - waves_r
		waves_c.beginPath()
		for(let dx = 0; dx <= width*z; ++dx){
			const dy = amplitude * Math.cos(tau * (-.1 + dx / (frequency*z)))
			waves_c.lineTo(dx, (y + dy)*z);
		}
		waves_c.stroke()
	})
	waves_c.globalCompositeOperation = 'source-in'
	waves_c.beginPath()
	waves_c.arc(half*z, half*z, waves_r*z, 0, 2*Math.PI)
	waves_c.fill()
	waves_c.restore()

	c.clearRect(0, 0, width*z, height*z)

	// wave gap 12 o'clock
	c.fillStyle = palettes.dial
	shape(
		rect_my(hour_len/2, hour_thick),
		half-hour_thick/2,
		half - hour_r_rect - hour_len/2,
	)

	c.fillStyle = palettes.mark
	c.lineWidth = lineWidth*z
	;[
		1, 3, 5, 7, 9, 11,
	].forEach(i => {
		const a = -i * tau_12 + tau_4 - bezel_angle
		shape(
			bezel_index.map(v => rot(a, v)),
			half + (bezel_r * cos(-a)),
			half + (bezel_r * sin(-a)),
		)
	})
	Array(60).fill().map((_, i) => i)
	.filter(x => x % 5)
	.forEach(i => {
		const a = -i * tau_60 + tau_4 - bezel_angle
		circle(
			bezel_mark_r,
			half + (bezel_r * cos(-a)),
			half + (bezel_r * sin(-a)),
		)}
	)
	Array(59).fill().map((_, i) => i)
	.filter(x => !((x+1) % 5))
	.forEach(i => {
		const a = -(i + 1) * tau_60 + tau_4 - bezel_angle
		const r = bezel_r - bezel_mark_r
		shape(
			bezel_minute.map(v => rot(a, v)),
			half + (r * cos(-a)),
			half + (r * sin(-a)),
		)
	})
	Array(12).fill().map((_, i) => i*5)
	.forEach(i => {
		const a = -i * tau_60 + tau_4
		shape(
			rect_my(minute_thick_five, -minute_len_five).map(v => rot(a, v)),
			half + (minute_r * cos(-a)),
			half + (minute_r * sin(-a)),
		)
	})
	;[
		1, 2, 3, 4,
		6, 7, 8, 9,
		11, 12, 13, 14,
		16, 17, 18, 19,
		21, 22, 23, 24,
		26, 27, 28,
		32, 33, 34,
		36, 37, 38, 39,
		41, 42, 43, 44,
		46, 47, 48, 49,
		51, 52, 53, 54,
		56, 57, 58, 59,
	]
	.forEach(i => {
		const a = -i * tau_60 + tau_4
		shape(
			rect_my(minute_thick, -minute_len).map(v => rot(a, v)),
			half + (minute_r * cos(-a)),
			half + (minute_r * sin(-a)),
		)
	})
	;[
		29, 31,
	].forEach(i => {
		const a = -i * tau_60 + tau_4
		const r = minute_r - minute_len
		shape(
			rect_my(minute_thick, 1).map(v => rot(a, v)),
			half + (r * cos(-a)),
			half + (r * sin(-a)),
		)
	})
	c.fillStyle = palettes.mark
	c.lineCap = 'square'
	c.strokeStyle = palettes.edge
	;[
		1, 2, 4, 5, 7, 8, 10, 11,
	].forEach(i => {
		circle(
			hour_radius,
			half + (hour_r * cos(i*tau_12)),
			half + (hour_r * sin(i*tau_12)),
		)
		c.stroke()
	})
	;[
		3, 9,
	].forEach(i => {
		const a = -i * tau_12 + tau_4
		shape(
			rect_my(hour_thick, hour_len).map(v => rot(a, v)),
			half + (hour_r_rect * cos(-a)),
			half + (hour_r_rect * sin(-a)),
		)
		c.closePath()
		c.stroke()
	})
	;[-1,1].forEach(i => {
		const a = -9/12*tau
		const gap = i * tw_gap
		shape(
			rect_my(hour_thick, hour_len).map(([x,y]) => rot(a, [x, y + gap])),
			half + (hour_r_rect * cos(-a)),
			half + (hour_r_rect * sin(-a)),
		)
		c.closePath()
		c.stroke()
	})
	// minute arcs
	c.lineWidth = 2 * minute_thick * z
	c.strokeStyle = palettes.mark
	;[
		1, 6, 11, 16, 21, 36, 41, 46, 51, 56,
	]
	.forEach(i => {
		const a = i * tau_60 - tau_4
		c.beginPath()
		c.arc(half*z, half*z, (minute_r - minute_thick)*z, a, a + tau / 20)
		c.stroke()
	})
	;[
		26, 32,
	]
	.forEach(i => {
		const a = i * tau_60 - tau_4
		c.beginPath()
		c.arc(half*z, half*z, (minute_r - minute_thick)*z, a, a + tau / 30)
		c.stroke()
	})
}
setTheme('Blue')
resize()
</script>
